import {
    ApiBadRequestResponse,
    ApiBearerAuth,
    ApiExtraModels,
    ApiForbiddenResponse,
    ApiNoContentResponse,
    ApiNotFoundResponse,
    ApiOkResponse,
    ApiParam,
    ApiProperty,
    ApiQuery,
    ApiUnauthorizedResponse,
    ApiUnprocessableEntityResponse,
    getSchemaPath
} from "@nestjs/swagger";
import { JwtGuard } from "src/auth/guards/jwt.guard";
import {
    applyDecorators,
    Delete,
    Get,
    HttpCode,
    HttpStatus,
    UseGuards
} from "@nestjs/common";
import { OAuthDBService } from "./oauth-db.service";

export class OAuthCredential {
    @ApiProperty({ description: "The ID of the OAuth2.0 credential." })
    readonly id?: number;

    @ApiProperty({
        description:
            "The access token used to interact with the OAuth provider's API."
    })
    readonly access_token: string;

    @ApiProperty({
        description: "The token used to refresh the access token once expired."
    })
    readonly refresh_token: string;

    @ApiProperty({
        description: "The date at which the access token will expire."
    })
    readonly expires_at: Date;

    @ApiProperty({
        description:
            "The scopes granted to the access token. It's a list of scope joined by spaces."
    })
    readonly scope: string;
}

export abstract class OAuthManager extends OAuthDBService {
    readonly OAUTH_TOKEN_URL: string;

    readonly OAUTH_REVOKE_URL: string;

    abstract getOAuthUrl(state: string, scope: string): string;

    abstract getCredentials(code: string): Promise<OAuthCredential>;

    abstract refreshCredential(
        oauthCredential: OAuthCredential
    ): Promise<OAuthCredential>;

    abstract revokeCredential(oauthCredential: OAuthCredential): Promise<void>;
}

export function OAuthController_getAuthorizationUrl(): MethodDecorator &
    ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Get("/:provider"),
        HttpCode(HttpStatus.OK),
        ApiParam({
            name: "provider",
            description: "The OAuth2.0 provider",
            example: "discord"
        }),
        ApiBearerAuth("bearer"),
        ApiOkResponse({
            description:
                "Returns the OAuth2.0 URL to which the user will have to log in to the service."
        }),
        ApiNotFoundResponse({
            description: "The specified provider is not supported."
        }),
        ApiUnauthorizedResponse({
            description:
                "This route is protected. The client must supply a Bearer token."
        }),
        ApiQuery({
            name: "scope",
            description:
                "The scopes required for the OAuth2.0 credential. It's a whitespace-joined string list.",
            example: "identify connections email"
        }),
        ApiQuery({
            name: "redirect_uri",
            description:
                "The URI to which the user will be redirected once the authentication flow is successful.",
            example: "http://localhost:8081/oauth/discord/callback"
        })
    );
}

export function OAuthController_callback(): MethodDecorator & ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Get("/:provider/callback"),
        HttpCode(HttpStatus.OK),
        ApiParam({
            name: "provider",
            description: "The OAuth2.0 provider",
            example: "discord"
        }),
        ApiNotFoundResponse({
            description: "The specified provider is not supported."
        }),
        ApiBearerAuth("bearer"),
        ApiOkResponse({
            description: "The auth flow has been completed successfully."
        }),
        ApiForbiddenResponse({
            description:
                "The 'state' attribute stored in the user's session is either invalid or does not match the one returned by the OAuth provider. This may happen during a CSRF attack."
        }),
        ApiBadRequestResponse({
            description: "The 'code' is invalid."
        }),
        ApiQuery({
            name: "code",
            description:
                "The 'code' query returned by the OAuth provider. It will be used as an exchange method for access and refresh tokens."
        }),
        ApiQuery({
            name: "state",
            description:
                "The 'state' query returned by the OAuth provider. It is a hash generated by the backend when requesting the OAuth URL for authorization. That query must appear in the OAuth provider's response in order to check for a potential CSRF attack and protect the user."
        })
    );
}

export function OAuthController_credentials(): MethodDecorator &
    ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Get("/:provider/credentials"),
        ApiExtraModels(OAuthCredential),
        ApiBearerAuth("bearer"),
        ApiParam({
            name: "provider",
            description: "The OAuth2.0 provider",
            example: "discord"
        }),
        ApiNotFoundResponse({
            description: "The specified provider is not supported."
        }),
        ApiOkResponse({
            description:
                "Returns all the OAuth2.0 credentials related to the user.",
            schema: {
                $ref: getSchemaPath(OAuthCredential)
            }
        }),
        ApiUnauthorizedResponse({
            description:
                "This route is protected. The client must supply a Bearer token."
        })
    );
}

export function OAuthController_revoke(): MethodDecorator & ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Delete("/:provider/revoke/:id"),
        ApiParam({
            name: "provider",
            description: "The OAuth2.0 provider",
            example: "discord"
        }),
        ApiParam({
            name: "id",
            description: "The ID of the credential to revoke.",
            type: Number
        }),
        HttpCode(HttpStatus.NO_CONTENT),
        ApiBearerAuth("bearer"),
        ApiNoContentResponse({
            description: "Revokes an oauth credential."
        }),
        ApiNotFoundResponse({
            description:
                "Either the provider name or the credential ID was invalid."
        }),
        ApiUnprocessableEntityResponse({
            description:
                "The given credential ID was found and belongs to the correct user, but it's OAuth provider is different from the current route provider.",
            example:
                "Unable to revoke the token. It may be from the wrong provider."
        }),
        ApiUnauthorizedResponse({
            description:
                "This route is protected. The client must supply a Bearer token."
        })
    );
}

export interface OAuthMetadata {
    state: string;
    requestedAt: number;
    redirectUri: string;
}
